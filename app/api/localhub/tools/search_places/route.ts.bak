/**
 * Search Places Tool Handler
 * Integrates with Google Geocoding API and Places Nearby Search API
 * to find local businesses and return structured content with map data
 */

import { NextResponse } from 'next/server';
import { badRequest, externalError, serverError } from '@/apps/localhub/server/utils';
import type { LatLng, Place, SearchData, ToolOutput } from '@/apps/localhub/server/types';

// Use Edge runtime for low latency
export const runtime = 'edge';

/**
 * Geocodes a location string using Google Geocoding API
 * Returns coordinates or null if geocoding fails
 */
async function geocodeWhere(where?: string): Promise<LatLng | null> {
  if (!where) {
    return null;
  }

  const apiKey = process.env.GOOGLE_PLACES_API_KEY;
  if (!apiKey) {
    throw new Error('GOOGLE_PLACES_API_KEY not configured');
  }

  const url = new URL('https://maps.googleapis.com/maps/api/geocode/json');
  url.searchParams.append('address', where);
  url.searchParams.append('key', apiKey);

  try {
    const response = await fetch(url.toString(), { cache: 'no-store' });
    const data = await response.json();

    if (data.status === 'OK' && data.results && data.results.length > 0) {
      const location = data.results[0].geometry.location;
      return { lat: location.lat, lng: location.lng };
    }

    return null;
  } catch (error) {
    console.error('Geocoding error:', error);
    return null;
  }
}

/**
 * Calculates viewport bounds from an array of coordinates with 5% padding
 * Returns null if points array is empty
 */
function expandViewportFromPoints(points: LatLng[]): SearchData['viewport'] | null {
  if (!points || points.length === 0) {
    return null;
  }

  // Calculate initial bounds
  let north = points[0].lat;
  let south = points[0].lat;
  let east = points[0].lng;
  let west = points[0].lng;

  for (const point of points) {
    if (point.lat > north) north = point.lat;
    if (point.lat < south) south = point.lat;
    if (point.lng > east) east = point.lng;
    if (point.lng < west) west = point.lng;
  }

  // Add 5% padding to all edges
  const padLat = (north - south) * 0.05;
  const padLng = (east - west) * 0.05;

  return {
    north: north + padLat,
    south: south - padLat,
    east: east + padLng,
    west: west - padLng
  };
}

/**
 * POST handler for search_places tool
 * Accepts query, where, center, radius_m, open_now, and language parameters
 */
export async function POST(request: Request) {
  try {
    // Parse request body
    const body = await request.json();
    const {
      query,
      where,
      center,
      radius_m = 5000,
      open_now = false,
      language
    } = body;

    // Validate required parameters
    if (!query || typeof query !== 'string') {
      return badRequest('Missing required parameter: query');
    }

    // Resolve coordinates
    let resolvedCenter: LatLng | null = null;
    let resolvedArea = '';

    if (center && typeof center === 'object' && center.lat && center.lng) {
      resolvedCenter = { lat: center.lat, lng: center.lng };
    } else if (where) {
      resolvedCenter = await geocodeWhere(where);
      resolvedArea = where;

      if (!resolvedCenter) {
        return badRequest('Could not resolve a search area from the provided location');
      }
    } else {
      return badRequest('Either center coordinates or where location string must be provided');
    }

    // Clamp radius between 100 and 50000 meters
    const clampedRadius = Math.max(100, Math.min(50000, radius_m));

    // Build Places Nearby Search API URL
    const apiKey = process.env.GOOGLE_PLACES_API_KEY;
    if (!apiKey) {
      return serverError('GOOGLE_PLACES_API_KEY not configured');
    }

    const placesUrl = new URL('https://maps.googleapis.com/maps/api/place/nearbysearch/json');
    placesUrl.searchParams.append('location', `${resolvedCenter.lat},${resolvedCenter.lng}`);
    placesUrl.searchParams.append('radius', clampedRadius.toString());
    placesUrl.searchParams.append('keyword', query);
    placesUrl.searchParams.append('key', apiKey);

    if (open_now) {
      placesUrl.searchParams.append('opennow', 'true');
    }

    if (language) {
      placesUrl.searchParams.append('language', language);
    }

    // Fetch from Places API
    const placesResponse = await fetch(placesUrl.toString(), { cache: 'no-store' });
    const placesData = await placesResponse.json();

    // Check API response status
    if (placesData.status !== 'OK' && placesData.status !== 'ZERO_RESULTS') {
      return externalError(
        `Places API error: ${placesData.status}${placesData.error_message ? ' - ' + placesData.error_message : ''}`
      );
    }

    // Process results (limit to 20)
    const results = placesData.results || [];
    const places: Place[] = results.slice(0, 20).map((r: any, index: number) => ({
      id: r.place_id || `place_${index}`,
      name: r.name,
      address: r.vicinity || r.formatted_address || '',
      phone: null, // Will be enriched later via Place Details API in Phase 2
      rating: r.rating ?? null,
      userRatingsTotal: r.user_ratings_total ?? null,
      location: {
        lat: r.geometry.location.lat,
        lng: r.geometry.location.lng
      },
      provider: {
        source: 'google_places',
        placeId: r.place_id
      }
    }));

    // Calculate viewport from all place locations
    const placeLocations = places.map(p => p.location);
    const viewport = expandViewportFromPoints(placeLocations) || {
      north: resolvedCenter.lat + 0.01,
      south: resolvedCenter.lat - 0.01,
      east: resolvedCenter.lng + 0.01,
      west: resolvedCenter.lng - 0.01
    };

    // Build search data
    const searchData: SearchData = {
      query,
      resolvedArea,
      center: resolvedCenter,
      viewport
    };

    // Return structured content response
    const output: ToolOutput = {
      search: searchData,
      places
    };

    return NextResponse.json(output);

  } catch (error) {
    console.error('Search places error:', error);
    return serverError(
      error instanceof Error ? error.message : 'An unexpected error occurred'
    );
  }
}
